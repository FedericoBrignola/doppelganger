# Doppelganger
AI framework that mix up Genetic Algorithms and Decision Trees to observe, learn and emulate the observed behavior

---

This is an University project developed by Giulia Ciancarelli and Federico Brignola at Sapienza University Of Rome.

---

Doppelganger is an AI project aiming at the induction of models of strategies starting from observed behaviors.
For example, we'll want to find the strategy model adopted by a person that plays a specific game.
To test the performance and efficiency of our algorithms, we used a simplified version of the classic snake game.

# The project structure
```
doppelganger
|   environment.py              # Interface to create and run genetic algorithms
|___examples                    # Preconfigured environments ready to run
|
|___game                        # snake game implementation
|   |   gameEngine.py           # Define the game's logic (given a state and an action, it returns a new state)
|   |   gameInstance.py         # Represents a game state
|   |   gui.py                  # Handle the rendering of a game state
|
|___player                      # Agents that can play the game
|   |   humanAgent.py           # Let a human player create it's own dataset (by plaing itself)
|   |   playerProtocol.py       # Python protocol, every agent must implement this protocol
|   |   simpleReactiveAgent.py  # An autonomous player with three different predefined strategies
|   |   treeAgent.py            # Player that chooses the actions by queryng a decisional tree
|
|___training
    |   decisionTree3.py        # Define the structure of a decisional tree
    |   geneticAlgorithm.py     # Base framework to build a genetic algorithm
    |   id3.py                  # An ID3 implementation
    |   logger.py               # Write a dataset by observing the environment
    |
    |___algorithms              # Collection of algorithms used by a genetic algorithm
        |   crossover.py        # Collection of crossover strategies
        |   firstGeneration.py  # Collection of methods to generate the first generation
        |   fitness.py          # Collection of fitness strategies
        |   mutation.py         # Collection of mutation strategies
        |   pruning.py          # Collection of pruning strategies
        |   selection.py        # Collection of selection strategies
```

# Requirements
- python >= 3.10
- graphviz

# Installation
On linux using venv
```
$ git clone https://gitea.sigmund.duckdns.org/giulia/doppelganger.git
$ cd doppelganger
$ python3 -m venv .venv
$ source .venv/bin/activate
$ pip install -r requirements.txt
```

# Getting started
> **NOTE:** Every example environment in `/examples/` folder creates a directory `local/<env_name>` in your working directory.
>
> ```
>local
>|___<env_name> 
>|   |   history.ga       # hexadecimal file where every row contains (best_individual, best_fitness, avg_fitness) about a specific generation 
>|   |   dataset.csv      # the dataset (can be generated by the trainer)
>|   |
>|   |___firstgen         # contains the individuals used for the "first generation"
>|   |   |   <id>.dtree    # where <id> is the unique identifier of the individual, in the range [0,n] 
>|   |
>|   |___lastgen          # contains all the individuals of the last generation computed, these will be used to resume an interrupted execution
>|       |  <id>.dtree    # same as firstgen
> ```

Run the example environment `/examples/env1.1.py` with the following command
> **NOTE:** May take some time to run (about 4 minutes on a 4-core CPU)
```
python3 examples/env1.1.py
```

This environment will create a dataset of 30k examples using the **LAgent** then generate 10 different decision trees using the id3 algorithm and compute 10 generations with the genetic algorithm.
At the end of execution the process generate a graph `local/env1.1/historyGraph.png` showing the best and avarege fitness for each generation.


# Environment
An environment is an instance of `environment.Environment`, and its purpose is to aggregate every configuration needed to run a genetic algorithm.
The most important methods are:
- `Environment::setAlgorithm(algorithm)`: Where `algorithm` is a function that return an instance of `geneticAlgorithm.Pack`
- `Environment::setFeatures(features, extractor)`: Where `features` is an instance of `training.decisionTree3.FeatureSet` and `extractor` is a function that transforms a "state of the world" into a map<"feature name", "value"> 

# Console
The console is the primary interface for performing tasks in an environment.

### Usage
```python
if __name__ == "__main__":
    # Load the environment
    c = Console("local/env1.1", Environemt)
    
    # Create the dataset
    c.train(maxTimeSeconds=10)
    
    # Run the genetic algorithm
    c.runAllgorithm()
    
    # when the genetic algorithm stop show the results
    c.drawHistoryGraph()
    c.printDecisionTree()
    c.replay()
```

`Console::runAlgorithm` starts the genetic algorithm execution.

`Console::train` generates a dataset observing the environment's agent.

`Console::replay` plays a game with the best individual for each generation.

`Console::printDecisionTree` prints the best decision tree of a generation.

`Console::drawHistoryGraph` draws a graph showing the best and average fitness for each generation.
